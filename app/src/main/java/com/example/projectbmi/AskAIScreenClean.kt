package com.example.projectbmi

import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.*
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.border
import androidx.compose.foundation.background
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.outlined.*
import androidx.compose.material.ripple.rememberRipple
import androidx.compose.material3.*
import androidx.compose.material3.ripple
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.example.projectbmi.model.DailyQuestParams
import com.example.projectbmi.model.QuestTask
import com.example.projectbmi.AIRepository
import com.example.projectbmi.DeepseekRepository
import com.example.projectbmi.ui.components.UserChatBubble
import com.example.projectbmi.ui.components.AIChatBubble
import com.example.projectbmi.ui.components.AITypingIndicator
import com.example.projectbmi.utils.NetworkUtils
import kotlinx.coroutines.launch
import android.widget.Toast
import com.example.projectbmi.questionnaire.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AskAIScreenClean(
    navController: NavController,
    userBMICategory: String = "normal",
    onSaveSchedule: (schedule: List<QuestTask>) -> Unit
) {
    val context = LocalContext.current
    var state by remember { mutableStateOf(UserDiscoveryState(bmiCategory = userBMICategory)) }
    var generated by remember { mutableStateOf<List<QuestTask>?>(null) }
    var regenerationVersion by remember { mutableStateOf(0) }  // Track regenerations
    var isRegenerating by remember { mutableStateOf(false) }  // Track loading state
    var regenerateCount by remember { mutableStateOf(0) }  // Track how many times regenerated
    val maxRegenerations = 4  // Limit to 4 regenerations (5 pools total - 1 initial generation)
    val generatedSchedulesHistory = remember { mutableStateListOf<List<QuestTask>>() }  // Track ALL generated schedules
    val usedPoolIndices = remember { mutableStateListOf<Int>() }  // Track ALL used pool indices
    var selectedAnswer by remember { mutableStateOf<String?>(null) }  // Track selected answer for visual feedback
    var isAdvancing by remember { mutableStateOf(false) }  // Track if advancing to next question
    var hasGeneratedOnce by remember { mutableStateOf(false) }  // Track if we've already generated once in this session

    // AI chat state
    var aiTips by remember { mutableStateOf<List<String>>(emptyList()) }
    var aiRequestedForChat by remember { mutableStateOf(false) }
    var aiSummary by remember { mutableStateOf<String?>(null) }
    var isGeneratingSummary by remember { mutableStateOf(false) }

    val scope = rememberCoroutineScope()
    
    // Gradient background colors
    val gradientColors = listOf(
        Color(0xFFF8F9FF),
        Color(0xFFE8ECFF)
    )

    Box(modifier = Modifier
        .fillMaxSize()
        .background(Brush.verticalGradient(gradientColors))
    ) {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text("Ask AI / Discovery") },
                    navigationIcon = {
                        IconButton(onClick = { 
                            // Handle back navigation based on current step
                            when {
                                generated != null -> {
                                    // If viewing generated schedule, go back to summary (but DON'T clear generated)
                                    state = state.copy(currentStep = 7)
                                }
                                state.currentStep > 1 -> {
                                    // If in questions/chat/summary, go to previous step
                                    state = state.copy(currentStep = state.currentStep - 1)
                                }
                                else -> {
                                    // If at first step, exit to previous screen
                                    navController.popBackStack()
                                }
                            }
                        }) { Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back") }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color.Transparent
                    )
                )
            },
            containerColor = Color.Transparent
        ) { paddingValues ->
        val scrollState = rememberScrollState()

        // Log when generated state changes
        LaunchedEffect(generated, regenerationVersion) {
            android.util.Log.d("AskAI", "Generated state changed: ${generated?.size ?: "null"}, version: $regenerationVersion")
        }
        
        // Ensure background async work runs in a composable-safe coroutine
        LaunchedEffect(state.currentStep, aiRequestedForChat) {
            if (state.currentStep == 6 && !aiRequestedForChat) {
                aiRequestedForChat = true
                try {
                    val params = DailyQuestParams(
                        bmiCategory = state.bmiCategory,
                        goal = state.primaryGoal ?: "maintain",
                        intensity = state.exerciseIntensity ?: "medium",
                        timeAvailable = mapDaysToTime(state.daysAvailable),
                        daysPerWeek = mapDaysToDaysPerWeek(state.daysAvailable),
                        focusArea = state.focusArea ?: "mixed",
                        healthStatus = "healthy",
                        exerciseHistory = state.experienceLevel ?: "intermediate",
                        dietaryPreference = "omnivore"
                    )
                    aiTips = AIRepository.generateQuickTips(0.0f, state.bmiCategory, "unknown")
                } catch (_: Exception) {
                    aiTips = emptyList()
                }
            }
        }

        // When showing preview or questionnaire (steps 1-5), don't use verticalScroll
        // LazyColumn can't be nested in scrollable parent
        val isQuestionnaire = state.currentStep in 1..5
        val useScroll = generated == null && !isQuestionnaire
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .then(if (!isQuestionnaire) Modifier.padding(16.dp) else Modifier)
                .then(if (useScroll) Modifier.verticalScroll(scrollState) else Modifier),
            verticalArrangement = if (isQuestionnaire) Arrangement.Top else Arrangement.spacedBy(16.dp)
        ) {
            // Progress indicator (only show for non-questionnaire steps)
            if (!isQuestionnaire) {
                LinearProgressIndicator(progress = { (state.currentStep - 1) / 7f }, modifier = Modifier.fillMaxWidth())
            }

            when {
                generated != null -> {
                    key(regenerationVersion) {
                        PreviewAndSave(
                            schedule = generated!!,
                            isLoading = isRegenerating,
                            regenerateCount = regenerateCount,
                            maxRegenerations = maxRegenerations,
                            onSave = {
                                onSaveSchedule(generated!!)
                            
                            // Clear schedule history after save
                            generatedSchedulesHistory.clear()
                            usedPoolIndices.clear()
                            regenerateCount = 0
                            hasGeneratedOnce = false  // Reset flag so next generation works
                            android.util.Log.d("AskAI", "Schedule saved, history cleared, hasGeneratedOnce reset")
                            
                            // Navigate to result page with BMI data
                            val prefs = context.getSharedPreferences("bmi_prefs", android.content.Context.MODE_PRIVATE)
                            val bmi = prefs?.getString("last_bmi", "0.0") ?: "0.0"
                            val category = prefs?.getString("last_category", "Normal Weight") ?: "Normal Weight"
                            val gender = prefs?.getString("last_gender", "Male") ?: "Male"
                            
                            android.util.Log.d("AskAI", "Navigation params - BMI: $bmi, Category: $category, Gender: $gender")
                            
                            val encodedCategory = java.net.URLEncoder.encode(category, "UTF-8")
                            navController.navigate("result/$bmi/$encodedCategory/$gender")
                        },
                        onRegenerate = {
                            // Check if regeneration limit reached
                            if (regenerateCount >= maxRegenerations) {
                                android.util.Log.d("AskAI", "Regenerate limit reached: $regenerateCount/$maxRegenerations")
                                android.widget.Toast.makeText(
                                    context,
                                    "Maximum regenerations reached (${maxRegenerations}x). Please save this schedule or go back.",
                                    android.widget.Toast.LENGTH_SHORT
                                ).show()
                                return@PreviewAndSave
                            }
                            
                            // Regenerate schedule with same params - ensure uniqueness
                            isRegenerating = true
                            regenerateCount++
                            android.util.Log.d("AskAI", "Regenerate clicked #$regenerateCount/$maxRegenerations")
                            android.util.Log.d("AskAI", "Current history size: ${generatedSchedulesHistory.size}, Used pools: $usedPoolIndices")
                            scope.launch {
                                try {
                                    // Long delay (5 seconds) to ensure random seed is VERY different
                                    kotlinx.coroutines.delay(5000)
                                    android.util.Log.d("AskAI", "5 second delay complete, calling generate...")
                                    
                                    val params = DailyQuestParams(
                                        bmiCategory = state.bmiCategory,
                                        goal = state.primaryGoal ?: "maintain",
                                        intensity = state.exerciseIntensity ?: "medium",
                                        timeAvailable = mapDaysToTime(state.daysAvailable),
                                        daysPerWeek = mapDaysToDaysPerWeek(state.daysAvailable),
                                        focusArea = state.focusArea ?: "mixed",
                                        healthStatus = "healthy",
                                        exerciseHistory = state.experienceLevel ?: "intermediate",
                                        dietaryPreference = "omnivore"
                                    )
                                    
                                    // Try to generate unique schedule (max 5 attempts)
                                    var newSchedule: List<QuestTask>? = null
                                    var attempts = 0
                                    val maxAttempts = 5
                                    
                                    while (attempts < maxAttempts) {
                                        attempts++
                                        android.util.Log.d("AskAI", "Generation attempt $attempts/$maxAttempts, excluding pools: $usedPoolIndices")
                                        
                                        val candidate = AIRepository.generateWeeklySchedule(params, excludePoolIndices = usedPoolIndices.toList())
                                        val candidatePoolIndex = AIRepository.lastGeneratedPoolIndex
                                        
                                        // Check if this schedule is unique (compare with history)
                                        val isUnique = generatedSchedulesHistory.none { existingSchedule ->
                                            schedulesSimilar(existingSchedule, candidate)
                                        }
                                        
                                        android.util.Log.d("AskAI", "Attempt $attempts: Pool $candidatePoolIndex, Unique: $isUnique")
                                        
                                        if (isUnique) {
                                            newSchedule = candidate
                                            generatedSchedulesHistory.add(candidate)
                                            usedPoolIndices.add(candidatePoolIndex)
                                            android.util.Log.d("AskAI", "SUCCESS! Found unique schedule on attempt $attempts. Pool: $candidatePoolIndex")
                                            android.util.Log.d("AskAI", "First task: ${candidate.firstOrNull()?.task ?: "none"}")
                                            break
                                        } else {
                                            android.util.Log.d("AskAI", "Schedule similar to existing, retrying...")
                                        }
                                    }
                                    
                                    if (newSchedule != null) {
                                        generated = newSchedule
                                        android.util.Log.d("AskAI", "Generated NEW unique schedule, size: ${newSchedule.size}")
                                    } else {
                                        android.util.Log.w("AskAI", "Could not generate unique schedule after $maxAttempts attempts, using last attempt")
                                        generated = AIRepository.generateWeeklySchedule(params, excludePoolIndices = usedPoolIndices.toList())
                                        generated?.let { 
                                            generatedSchedulesHistory.add(it)
                                            usedPoolIndices.add(AIRepository.lastGeneratedPoolIndex)
                                        }
                                    }
                                    
                                    regenerationVersion++  // Force recomposition
                                    android.util.Log.d("AskAI", "Regenerated schedule, version now: $regenerationVersion")
                                    android.util.Log.d("AskAI", "Total schedules in history: ${generatedSchedulesHistory.size}")
                                } catch (e: Exception) {
                                    android.util.Log.e("AskAI", "Error regenerating", e)
                                    generated = emptyList()
                                } finally {
                                    isRegenerating = false
                                    android.util.Log.d("AskAI", "Regenerate complete, isRegenerating = false")
                                }
                            }
                        }
                    )
                    }
                }

                state.currentStep in 1..5 -> {
                    // ═══════════════════════════════════════════════════
                    // CLEAN ARCHITECTURE: Single reusable component for ALL screens
                    // Zero code duplication - all 5 screens use same QuestionnaireScreen
                    // ═══════════════════════════════════════════════════
                    
                    val screenIndex = state.currentStep - 1
                    var currentScreen = QuestionnaireData.screens[screenIndex]
                    
                    // For step 1 (fitness goal), filter options based on BMI category
                    if (state.currentStep == 1) {
                        android.util.Log.d("AskAI", "Filtering goals for BMI category: '${state.bmiCategory}'")
                        val filteredGoalOptions = QuestionnaireData.getFilteredGoalOptions(state.bmiCategory)
                        android.util.Log.d("AskAI", "Original options: ${currentScreen.options.size}, Filtered: ${filteredGoalOptions.size}")
                        currentScreen = currentScreen.copy(options = filteredGoalOptions)
                    }
                    
                    // Build selected options set based on current screen
                    val selectedOptions = when (state.currentStep) {
                        1 -> state.primaryGoal?.let { setOf(it) } ?: emptySet()
                        2 -> state.exerciseIntensity?.let { setOf(it) } ?: emptySet()
                        3 -> state.daysAvailable?.let { setOf(it) } ?: emptySet()
                        4 -> state.experienceLevel?.let { setOf(it) } ?: emptySet()
                        5 -> state.focusArea?.let { setOf(it) } ?: emptySet()  // Focus area (can be multi-select later)
                        else -> emptySet()
                    }
                    
                    // Clean auto-advance pattern - no Next button needed
                    Box(modifier = Modifier.fillMaxSize()) {
                        // Multi-select needs manual advance with floating action button
                        if (currentScreen.isMultiSelect) {
                            Box(modifier = Modifier.fillMaxSize()) {
                                QuestionnaireScreen(
                                    screen = currentScreen,
                                    selectedOptions = selectedOptions,
                                    onSelectionChange = { value ->
                                        // For multi-select focus area, toggle selection
                                        state = if (value == state.focusArea) {
                                            state.copy(focusArea = null)
                                        } else {
                                            state.copy(focusArea = value)
                                        }
                                    },
                                    progress = state.currentStep / 5f
                                )
                                
                                // Floating Next button for multi-select
                                if (state.focusArea != null) {
                                    FloatingActionButton(
                                        onClick = {
                                            state = state.copy(currentStep = 6)
                                        },
                                        modifier = Modifier
                                            .align(Alignment.BottomEnd)
                                            .padding(24.dp),
                                        containerColor = Color(0xFF6366F1)
                                    ) {
                                        Icon(
                                            imageVector = Icons.Default.ArrowForward,
                                            contentDescription = "Next",
                                            tint = Color.White
                                        )
                                    }
                                }
                            }
                        } else {
                            // Single-select with auto-advance
                            QuestionnaireScreen(
                                screen = currentScreen,
                                selectedOptions = selectedOptions,
                                onSelectionChange = { value ->
                                    // Update state based on questionnaire step
                                    state = when (state.currentStep) {
                                        1 -> state.copy(primaryGoal = value)  // Fitness goal
                                        2 -> state.copy(exerciseIntensity = value)  // Intensity level
                                        3 -> state.copy(daysAvailable = value)  // Days per week
                                        4 -> state.copy(experienceLevel = value)  // Experience level
                                        else -> state
                                    }
                                    // Auto-advance after 800ms
                                    scope.launch {
                                        kotlinx.coroutines.delay(800)
                                        state = state.copy(currentStep = state.currentStep + 1)
                                    }
                                },
                                progress = state.currentStep / 5f
                            )
                        }
                    }
                }

                state.currentStep == 6 -> {

                    // Top cards: AI Suggestions & Follow-ups
                    if (aiTips.isNotEmpty()) {
                        Card(modifier = Modifier.fillMaxWidth()) {
                            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                                Text("AI Suggestions", fontWeight = FontWeight.Bold)
                                aiTips.forEach { t -> Text("• $t") }
                            }
                        }
                    }

                    // Chat area: messages list (fixed-height) + input row
                    val chatMessages = remember { mutableStateListOf<Pair<String, String>>() }
                    var chatInput by remember { mutableStateOf("") }
                    var isAITyping by remember { mutableStateOf(false) }
                    val chatScrollState = rememberScrollState()

                    Card(modifier = Modifier.fillMaxWidth()) {
                        Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                            Text("Chat with AI", fontWeight = FontWeight.SemiBold)
                            
                            Box(modifier = Modifier
                                .fillMaxWidth()
                                .heightIn(min = 180.dp, max = 280.dp)
                                .border(1.dp, MaterialTheme.colorScheme.outline)
                                .background(MaterialTheme.colorScheme.surface)
                                .verticalScroll(chatScrollState)
                            ) {
                                if (chatMessages.isEmpty() && !isAITyping) {
                                    Text("Start the conversation by typing below.", modifier = Modifier.padding(12.dp).align(Alignment.TopStart))
                                } else {
                                    Column(modifier = Modifier.fillMaxWidth().padding(8.dp), verticalArrangement = Arrangement.spacedBy(4.dp)) {
                                        chatMessages.forEach { msg ->
                                            val role = msg.first
                                            val text = msg.second
                                            
                                            // Check if message is an error message
                                            if (role == "error") {
                                                // Error message styling
                                                Box(
                                                    modifier = Modifier
                                                        .fillMaxWidth()
                                                        .background(MaterialTheme.colorScheme.errorContainer, MaterialTheme.shapes.medium)
                                                        .padding(12.dp)
                                                ) {
                                                    Text(
                                                        text = text,
                                                        color = MaterialTheme.colorScheme.onErrorContainer,
                                                        fontSize = 14.sp
                                                    )
                                                }
                                            } else if (role == "user") {
                                                UserChatBubble(text)
                                            } else {
                                                AIChatBubble(text)
                                            }
                                        }
                                        if (isAITyping) {
                                            AITypingIndicator()
                                        }
                                    }
                                }
                            }

                            // Input row: TextField + Send
                            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp), verticalAlignment = Alignment.CenterVertically) {
                                OutlinedTextField(
                                    value = chatInput,
                                    onValueChange = { chatInput = it },
                                    placeholder = { Text("Ask AI... type a question") },
                                    modifier = Modifier.weight(1f),
                                    singleLine = true,
                                    enabled = !isAITyping
                                )
                                Button(
                                    onClick = {
                                        if (chatInput.isNotBlank()) {
                                            // Check network before sending
                                            if (!NetworkUtils.isInternetAvailable(context)) {
                                                chatMessages.add(Pair("error", "❌ No internet connection. Please check your network."))
                                                return@Button
                                            }
                                            
                                            val messageCopy = chatInput.trim()
                                            chatMessages.add(Pair("user", messageCopy))
                                            chatInput = ""
                                            isAITyping = true
                                            scope.launch {
                                                try {
                                                    // Read current BMI data from SharedPreferences
                                                    val prefs = context.getSharedPreferences("bmi_prefs", android.content.Context.MODE_PRIVATE)
                                                    val currentBmi = prefs?.getString("last_bmi", "Not recorded") ?: "Not recorded"
                                                    val currentCategory = prefs?.getString("last_category", "Unknown") ?: "Unknown"
                                                    
                                                    // Build comprehensive user profile context with all discovery answers AND BMI data
                                                    val contextProfile = """
User Discovery Profile:
- Primary Goal: ${state.primaryGoal ?: "Not specified"}
- Exercise Frequency: ${state.exerciseFrequency ?: "Not specified"}
- Dietary Preferences: ${state.eatingPattern ?: "Not specified"}
- Sleep Hours: ${state.sleepHours ?: "Not specified"}
- Health Challenges: ${state.challenges.joinToString(", ") { it }}
- BMI Category: ${state.bmiCategory}

Current Health Metrics:
- Current BMI: $currentBmi
- BMI Category: $currentCategory

Context: You are a personalized fitness and health coach. Use the above profile and health metrics to give specific, actionable advice. When user asks about their progress, compare their current metrics to their goals.
                                                    """.trimIndent()
                                                    val reply = DeepseekRepository.sendMessage(messageCopy, contextProfile)
                                                    isAITyping = false
                                                    
                                                    // Check if response is an error message
                                                    if (reply.startsWith("❌") || reply.startsWith("⏱️") || reply.startsWith("⚠️")) {
                                                        chatMessages.add(Pair("error", reply))
                                                    } else {
                                                        chatMessages.add(Pair("ai", reply))
                                                    }
                                                } catch (e: Exception) {
                                                    isAITyping = false
                                                    chatMessages.add(Pair("error", "⚠️ Error: ${e.localizedMessage ?: "AI failed to respond"}"))
                                                }
                                            }
                                        }
                                    },
                                    modifier = Modifier.height(56.dp),
                                    enabled = !isAITyping
                                ) {
                                    Text(if (isAITyping) "Sending..." else "Send")
                                }
                            }
                        }
                    }

                    // Primary full-width action - Generate Summary with quick advance
                    Button(onClick = {
                        // Validate that user has chatted with AI first
                        if (chatMessages.isEmpty()) {
                            Toast.makeText(context, "Please chat with AI first before generating summary", Toast.LENGTH_SHORT).show()
                            return@Button
                        }
                        
                        isGeneratingSummary = true
                        scope.launch {
                            try {
                                // Build comprehensive context including chat conversation
                                val chatHistory = chatMessages
                                    .filter { it.first != "error" }
                                    .joinToString("\n") { (role, text) ->
                                        "${if (role == "user") "User" else "Coach"}: $text"
                                    }
                                
                                // Get user's progress stats from stored schedule
                                val progressStats = getProgressStats(context, generated ?: emptyList())
                                
                                val summaryPrompt = """
Based on the user's profile and our conversation, create a personalized fitness and wellness summary:

User Discovery Profile:
- Primary Goal: ${state.primaryGoal ?: "Not specified"}
- Exercise Intensity: ${state.exerciseIntensity ?: "Not specified"}
- Days Available: ${state.daysAvailable ?: "Not specified"}
- Experience Level: ${state.experienceLevel ?: "Not specified"}
- Focus Area: ${state.focusArea ?: "Not specified"}
- BMI Category: ${state.bmiCategory}

User Progress:
- Current Schedule: ${if ((generated ?: emptyList()).isNotEmpty()) "${(generated ?: emptyList()).size} days planned" else "No schedule yet"}
- Tasks Completed: ${progressStats["completedCount"] ?: 0} out of ${progressStats["totalCount"] ?: 0}
- Completion Rate: ${progressStats["completionRate"] ?: "N/A"}%
- Consistency: ${progressStats["consistency"] ?: "Just started"}
- Last Updated: ${progressStats["lastUpdated"] ?: "Today"}

Conversation History:
$chatHistory

Please provide:
1. A personalized wellness summary acknowledging their current progress
2. 3-5 key action items tailored to their specific situation (consider their progress history)
3. A motivational message based on their consistency and effort
4. Next steps to build on their momentum

Keep the summary concise but comprehensive, and reference their actual progress where relevant.
                                """.trimIndent()
                                
                                aiSummary = DeepseekRepository.sendMessage(summaryPrompt, "")
                                // Auto-advance to next step after generating summary
                                state = state.copy(currentStep = 7)
                            } catch (e: Exception) {
                                aiSummary = "⚠️ Could not generate summary: ${e.localizedMessage ?: "Try again"}"
                            } finally {
                                isGeneratingSummary = false
                            }
                        }
                    }, modifier = Modifier.fillMaxWidth(), enabled = !isGeneratingSummary) {
                        if (isGeneratingSummary) {
                            Row(horizontalArrangement = Arrangement.spacedBy(8.dp), verticalAlignment = Alignment.CenterVertically) {
                                CircularProgressIndicator(modifier = Modifier.size(20.dp), strokeWidth = 2.dp, color = MaterialTheme.colorScheme.onPrimary)
                                Text("Generating...")
                            }
                        } else {
                            Text("Generate Summary")
                        }
                    }
                }

                state.currentStep == 7 -> {
                    SummaryStep(state = state, aiSummary = aiSummary, isLoading = state.isLoading, onGenerate = {
                        // Only generate if we haven't generated yet in this session
                        if (hasGeneratedOnce) {
                            android.util.Log.d("AskAI", "Schedule already generated in this session, skipping regeneration")
                            Toast.makeText(context, "Schedule already generated. Click Regenerate to create a new one or Save to finish.", Toast.LENGTH_SHORT).show()
                            return@SummaryStep
                        }
                        
                        android.util.Log.d("AskAI", "Generate button clicked at step 7")
                        state = state.copy(isLoading = true)
                        scope.launch {
                            try {
                                val params = DailyQuestParams(
                                    bmiCategory = state.bmiCategory,
                                    goal = state.primaryGoal ?: "maintain",
                                    intensity = state.exerciseIntensity ?: "medium",
                                    timeAvailable = mapDaysToTime(state.daysAvailable),
                                    daysPerWeek = mapDaysToDaysPerWeek(state.daysAvailable),
                                    focusArea = state.focusArea ?: "mixed",
                                    healthStatus = "healthy",
                                    exerciseHistory = state.experienceLevel ?: "intermediate",
                                    dietaryPreference = "omnivore"
                                )
                                android.util.Log.d("AskAI", "Generating INITIAL schedule with params: $params")
                                generated = AIRepository.generateWeeklySchedule(params, excludePoolIndices = emptyList())  // First generation, no exclusion
                                val poolIndex = AIRepository.lastGeneratedPoolIndex
                                
                                // Store in history
                                generated?.let { schedule ->
                                    generatedSchedulesHistory.clear()  // Clear old history for fresh start
                                    usedPoolIndices.clear()
                                    generatedSchedulesHistory.add(schedule)
                                    usedPoolIndices.add(poolIndex)
                                    hasGeneratedOnce = true  // Mark that we've generated
                                    regenerateCount = 0  // Reset regenerate count for this generation
                                    android.util.Log.d("AskAI", "Stored initial schedule in history. Pool: $poolIndex, hasGeneratedOnce: true")
                                }
                                
                                // Wait 5 seconds before finishing to show loading state and ensure good random seed
                                kotlinx.coroutines.delay(5000)
                                regenerationVersion++  // Force recomposition on first generate
                                android.util.Log.d("AskAI", "Generated INITIAL schedule size: ${generated?.size ?: 0}, version: $regenerationVersion, pool index: $poolIndex")
                                generated?.forEachIndexed { idx, task ->
                                    android.util.Log.d("AskAI", "Task $idx: ${task.day} - ${task.task}")
                                }
                            } catch (e: Exception) {
                                android.util.Log.e("AskAI", "Error generating schedule", e)
                                generated = emptyList()
                            }
                            state = state.copy(isLoading = false)
                        }
                    }, onBack = { state = state.copy(currentStep = 6) })
                }
            }
        }
    }
    }  // Close Box
}
// ═══════════════════════════════════════════════════
// OLD COMPONENTS (Kept for backward compatibility)
// These are no longer used - all screens now use QuestionnaireScreen
// ═══════════════════════════════════════════════════

// Reusable question composables to ensure consistent spacing and protect against large font scales
@Composable
fun QuestionStepRadio(
    title: String,
    options: List<Pair<String, String>>,
    selectedValue: String?,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onSelect: (String) -> Unit
) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(
            title,
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold,
            modifier = Modifier
                .fillMaxWidth()
                .heightIn(min = 52.dp)
                .padding(bottom = 8.dp),
            maxLines = 3,
            overflow = TextOverflow.Ellipsis
        )

        Spacer(modifier = Modifier.height(10.dp))

        Column(verticalArrangement = Arrangement.spacedBy(10.dp)) {
            options.forEach { (label, value) ->
                val isSelected = selectedValue == value
                val isJustSelected = selectedAnswer == value && isAdvancing
                
                // Animasi scale untuk item yang dipilih
                val scale by animateFloatAsState(
                    targetValue = if (isJustSelected) 1.05f else 1f,
                    animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy, stiffness = Spring.StiffnessLow),
                    label = "scale"
                )
                
                val backgroundColor = when {
                    isJustSelected -> MaterialTheme.colorScheme.primaryContainer
                    isSelected -> MaterialTheme.colorScheme.surfaceVariant
                    else -> MaterialTheme.colorScheme.surface
                }
                
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .graphicsLayer(scaleX = scale, scaleY = scale),
                    colors = CardDefaults.cardColors(containerColor = backgroundColor)
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .selectable(
                                selected = isSelected,
                                onClick = { if (!isAdvancing) onSelect(value) }
                            )
                            .heightIn(min = 56.dp)
                            .padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        RadioButton(
                            selected = isSelected,
                            onClick = { if (!isAdvancing) onSelect(value) }
                        )
                        Spacer(modifier = Modifier.width(14.dp))
                        Text(
                            label,
                            fontSize = 16.sp,
                            modifier = Modifier.weight(1f),
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis,
                            fontWeight = if (isJustSelected) FontWeight.Bold else FontWeight.Normal
                        )
                        // Show checkmark when selected
                        if (isJustSelected) {
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("✓", fontSize = 20.sp, color = MaterialTheme.colorScheme.primary)
                        }
                    }
                }
            }
        }
        
        // Show "Moving to next question..." when advancing
        AnimatedVisibility(visible = isAdvancing) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 16.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(modifier = Modifier.size(16.dp), strokeWidth = 2.dp)
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    "Moving to next question...",
                    fontSize = 14.sp,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
fun QuestionStepCheckbox(
    title: String,
    options: List<String>,
    selected: List<String>,
    onToggle: (String) -> Unit
) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(
            title,
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold,
            modifier = Modifier
                .fillMaxWidth()
                .heightIn(min = 52.dp)
                .padding(bottom = 8.dp),
            maxLines = 3,
            overflow = TextOverflow.Ellipsis
        )

        Spacer(modifier = Modifier.height(10.dp))

        Column(verticalArrangement = Arrangement.spacedBy(10.dp)) {
            options.forEach { label ->
                val isSelected = selected.contains(label)
                
                // Animasi scale untuk item yang dipilih
                val scale by animateFloatAsState(
                    targetValue = if (isSelected) 1.02f else 1f,
                    animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy),
                    label = "checkboxScale"
                )
                
                val backgroundColor = if (isSelected) {
                    MaterialTheme.colorScheme.primaryContainer
                } else {
                    MaterialTheme.colorScheme.surface
                }
                
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .graphicsLayer(scaleX = scale, scaleY = scale),
                    colors = CardDefaults.cardColors(containerColor = backgroundColor)
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onToggle(label) }
                            .heightIn(min = 56.dp)
                            .padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Checkbox(
                            checked = isSelected,
                            onCheckedChange = { onToggle(label) }
                        )
                        Spacer(modifier = Modifier.width(14.dp))
                        Text(
                            label,
                            fontSize = 16.sp,
                            modifier = Modifier.weight(1f),
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis,
                            fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal
                        )
                        // Show checkmark count
                        if (isSelected) {
                            Text("✓", fontSize = 20.sp, color = MaterialTheme.colorScheme.primary)
                        }
                    }
                }
            }
        }
        
        // Show selection count
        if (selected.isNotEmpty()) {
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                "${selected.size} selected",
                fontSize = 14.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Medium
            )
        }
    }
}

@Composable
fun StepPrimaryGoal(
    state: UserDiscoveryState,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onStateChange: (UserDiscoveryState) -> Unit
) {
    val options = listOf("Lose weight" to "weight-loss", "Gain weight" to "gain", "Maintain ideal weight" to "maintain", "Check BMI status" to "check")
    QuestionStepRadio(
        title = "What is your primary goal for using this app?",
        options = options,
        selectedValue = state.primaryGoal,
        selectedAnswer = selectedAnswer,
        isAdvancing = isAdvancing
    ) { value ->
        onStateChange(state.copy(primaryGoal = value))
    }
}

@Composable
fun StepExerciseFrequency(
    state: UserDiscoveryState,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onStateChange: (UserDiscoveryState) -> Unit
) {
    val options = listOf("Never" to "never", "1 - 2 times" to "one-two", "3 - 5 times" to "three-five", "Daily" to "daily")
    QuestionStepRadio(
        title = "How often do you exercise per week?",
        options = options,
        selectedValue = state.exerciseFrequency,
        selectedAnswer = selectedAnswer,
        isAdvancing = isAdvancing
    ) { value ->
        onStateChange(state.copy(exerciseFrequency = value))
    }
}

@Composable
fun StepEatingPattern(
    state: UserDiscoveryState,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onStateChange: (UserDiscoveryState) -> Unit
) {
    val options = listOf("Irregular" to "irregular", "Overeating" to "overeating", "Balanced" to "balanced", "Specific diet" to "specific")
    QuestionStepRadio(
        title = "What is your typical eating pattern?",
        options = options,
        selectedValue = state.eatingPattern,
        selectedAnswer = selectedAnswer,
        isAdvancing = isAdvancing
    ) { value ->
        onStateChange(state.copy(eatingPattern = value))
    }
}

@Composable
fun StepSleepHours(
    state: UserDiscoveryState,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onStateChange: (UserDiscoveryState) -> Unit
) {
    val options = listOf("< 5 hours" to "less-5", "5-7" to "5-7", "7-9" to "7-9", "> 9" to "more-9")
    QuestionStepRadio(
        title = "How many hours do you usually sleep per night?",
        options = options,
        selectedValue = state.sleepHours,
        selectedAnswer = selectedAnswer,
        isAdvancing = isAdvancing
    ) { value ->
        onStateChange(state.copy(sleepHours = value))
    }
}

@Composable
fun StepChallenges(state: UserDiscoveryState, onStateChange: (UserDiscoveryState) -> Unit) {
    val options = listOf("Finding time", "Diet pattern", "Lack of motivation", "Busy schedule", "Other")
    QuestionStepCheckbox(title = "What do you find most challenging about maintaining your ideal weight?", options = options, selected = state.challenges) { toggled ->
        val new = if (state.challenges.contains(toggled)) state.challenges - toggled else state.challenges + toggled
        onStateChange(state.copy(challenges = new))
    }
}

@Composable
fun SummaryStep(state: UserDiscoveryState, aiSummary: String? = null, isLoading: Boolean, onGenerate: () -> Unit, onBack: () -> Unit) {
    Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {
        aiSummary?.let { s ->
            val cleaned = remember(s) { sanitizeMarkdown(s) }
            Card(modifier = Modifier.fillMaxWidth()) {
                Column(modifier = Modifier.padding(12.dp)) {
                    Text("AI-generated Summary", fontWeight = FontWeight.Bold)
                    Spacer(modifier = Modifier.height(6.dp))
                    Text(cleaned)
                }
            }
        }

        Text("Summary", style = MaterialTheme.typography.headlineSmall)
        Card(modifier = Modifier.fillMaxWidth()) {
            Column(modifier = Modifier.padding(12.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                SummaryRow("Goal", state.primaryGoal ?: "—")
                HorizontalDivider()
                SummaryRow("Workout Intensity", state.exerciseIntensity ?: "—")
                HorizontalDivider()
                SummaryRow("Days Available", state.daysAvailable ?: "—")
                HorizontalDivider()
                SummaryRow("Experience Level", state.experienceLevel ?: "—")
                HorizontalDivider()
                SummaryRow("Focus Area", state.focusArea ?: "—")
            }
        }
        Button(onClick = onGenerate, modifier = Modifier.fillMaxWidth(), enabled = !isLoading) { Text("Generate") }
        OutlinedButton(onClick = onBack, modifier = Modifier.fillMaxWidth()) { Text("Back") }
    }
}

private fun sanitizeMarkdown(input: String): String {
    var t = input
    t = t.replace("**", "")
        .replace("*", "")
        .replace("_", "")
    t = t.split('\n').joinToString("\n") { line ->
        line.replace(Regex("""^\s*#{1,6}\s*"""), "")
    }
    t = t.split('\n').joinToString("\n") { line ->
        line.replace(Regex("""^\s*[-•]\s+"""), "• ")
    }
    t = t.replace("```", "")
        .replace("`", "")
    t = t.replace(Regex("""[ \t]{2,}"""), " ")
    return t.trim()
}

@Composable
fun PreviewAndSave(
    schedule: List<QuestTask>, 
    isLoading: Boolean = false, 
    regenerateCount: Int = 0,
    maxRegenerations: Int = 2,
    onSave: () -> Unit, 
    onRegenerate: () -> Unit
) {
    android.util.Log.d("PreviewAndSave", "Rendering: Schedule size: ${schedule.size}, isLoading: $isLoading, regenerateCount: $regenerateCount")
    if (schedule.isNotEmpty()) {
        android.util.Log.d("PreviewAndSave", "Schedule items: ${schedule.map { "${it.day}: ${it.task}" }}")
    }
    
    Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
            Text("Preview Schedule", style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.Bold)
            if (regenerateCount > 0) {
                Text(
                    "Regenerated: $regenerateCount/$maxRegenerations",
                    style = MaterialTheme.typography.bodySmall,
                    color = if (regenerateCount >= maxRegenerations) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
        
        if (isLoading) {
            // Show loading state
            Box(modifier = Modifier.weight(1f).fillMaxWidth(), contentAlignment = Alignment.Center) {
                Column(horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(48.dp),
                        color = MaterialTheme.colorScheme.primary,
                        strokeWidth = 4.dp
                    )
                    Text("Generating new schedule...", style = MaterialTheme.typography.bodyMedium, color = MaterialTheme.colorScheme.onSurfaceVariant)
                }
            }
        } else if (schedule.isEmpty()) {
            Box(modifier = Modifier.weight(1f).fillMaxWidth(), contentAlignment = Alignment.Center) {
                Text("No schedule generated yet", color = MaterialTheme.colorScheme.onSurfaceVariant)
            }
        } else {
            LazyColumn(
                modifier = Modifier.weight(1f).fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(schedule) { task ->
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    task.day.uppercase(),
                                    fontWeight = FontWeight.Bold,
                                    style = MaterialTheme.typography.labelLarge,
                                    color = MaterialTheme.colorScheme.primary
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    task.task,
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    }
                }
            }
        }
        
        // Action buttons
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
            OutlinedButton(
                onClick = onRegenerate, 
                modifier = Modifier.weight(1f), 
                enabled = !isLoading && regenerateCount < maxRegenerations
            ) {
                if (isLoading) {
                    CircularProgressIndicator(modifier = Modifier.size(20.dp), strokeWidth = 2.dp, color = MaterialTheme.colorScheme.onSurface)
                } else {
                    Text(if (regenerateCount >= maxRegenerations) "Limit Reached" else "Regenerate")
                }
            }
            Button(onClick = onSave, modifier = Modifier.weight(1f), enabled = !isLoading) {
                Text("Save")
            }
        }
    }
}

@Composable
fun SummaryRow(label: String, value: String) {
    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween) {
        Text(label)
        Text(value, fontWeight = FontWeight.Bold)
    }
}

fun mapFrequencyToIntensity(freq: String?): String = when (freq) {
    "never" -> "low"
    "one-two" -> "low"
    "three-five" -> "medium"
    "daily" -> "high"
    else -> "medium"
}

fun mapExerciseFrequencyToHistory(freq: String?): String = when (freq) {
    "never" -> "beginner"
    "one-two" -> "inconsistent"
    "three-five" -> "active"
    "daily" -> "active"
    else -> "beginner"
}

fun mapDaysToTime(days: String?): Int = when (days) {
    "3-4" -> 30  // Limited time per session
    "5-6" -> 45  // Moderate time per session
    "7" -> 60    // Full time per session
    else -> 45   // Default moderate
}

fun mapDaysToDaysPerWeek(days: String?): Int = when (days) {
    "3-4" -> 4   // 3-4 workout days
    "5-6" -> 6   // 5-6 workout days
    "7" -> 7     // Daily workouts
    else -> 7    // Default full week
}

/**
 * Check if two schedules are similar (more than 50% tasks are the same)
 * Returns true if schedules are similar (should be avoided), false if they're different enough
 */
fun schedulesSimilar(schedule1: List<QuestTask>, schedule2: List<QuestTask>): Boolean {
    if (schedule1.size != schedule2.size) return false
    
    var matchingTasks = 0
    for (i in schedule1.indices) {
        // Compare task descriptions (the main identifier)
        if (schedule1[i].task == schedule2[i].task) {
            matchingTasks++
        }
    }
    
    // If more than 50% tasks are the same, consider schedules similar
    val similarityThreshold = 0.5
    val similarity = matchingTasks.toDouble() / schedule1.size.toDouble()
    
    android.util.Log.d("ScheduleComparison", "Matching tasks: $matchingTasks/${schedule1.size}, Similarity: ${similarity * 100}%")
    
    return similarity > similarityThreshold
}

/**
 * Get user's progress statistics from saved schedule and completed tasks
 */
fun getProgressStats(context: android.content.Context, generatedSchedule: List<QuestTask>): Map<String, Any> {
    return try {
        val prefs = context.getSharedPreferences("daily_quest_prefs", android.content.Context.MODE_PRIVATE)
        
        // Get completed tasks for today
        val completedStr = prefs.getString("daily_completed", "") ?: ""
        val completedCount = if (completedStr.isBlank()) 0 else completedStr.split(",").size
        
        // Get total tasks from saved schedule
        val scheduleJson = prefs.getString("weekly_schedule_json", "") ?: ""
        val totalCount = if (scheduleJson.isBlank()) {
            generatedSchedule.size
        } else {
            try {
                com.google.gson.Gson().fromJson(scheduleJson, Array<QuestTask>::class.java).size
            } catch (e: Exception) {
                generatedSchedule.size
            }
        }
        
        // Calculate completion rate
        val completionRate = if (totalCount > 0) {
            ((completedCount * 100) / totalCount)
        } else {
            0
        }
        
        // Determine consistency message
        val consistency = when {
            completedCount == 0 -> "Just started - beginning the journey!"
            completionRate >= 80 -> "Excellent - highly consistent!"
            completionRate >= 60 -> "Good - maintaining momentum"
            completionRate >= 40 -> "Moderate - building the habit"
            else -> "Getting started - every step counts"
        }
        
        // Get last updated date
        val lastUpdated = prefs.getString("daily_completed_date", "") ?: "Today"
        val lastUpdatedDisplay = if (lastUpdated == java.time.LocalDate.now().toString()) "Today" else lastUpdated
        
        mapOf(
            "completedCount" to completedCount,
            "totalCount" to totalCount,
            "completionRate" to completionRate,
            "consistency" to consistency,
            "lastUpdated" to lastUpdatedDisplay
        )
    } catch (e: Exception) {
        mapOf(
            "completedCount" to 0,
            "totalCount" to 0,
            "completionRate" to 0,
            "consistency" to "Just started",
            "lastUpdated" to "Today"
        )
    }
}

// lightweight local state type shared with this file
// UserDiscoveryState is now defined in `UserDiscoveryState.kt` to be shared across files.
