package com.example.projectbmi

import androidx.compose.animation.animateColorAsState
import androidx.compose.animation.core.*
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.border
import androidx.compose.foundation.background
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.outlined.*
import androidx.compose.material.ripple.rememberRipple
import androidx.compose.material3.*
import androidx.compose.material3.ripple
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavController
import com.example.projectbmi.model.DailyQuestParams
import com.example.projectbmi.model.QuestTask
import com.example.projectbmi.AIRepository
import com.example.projectbmi.DeepseekRepository
import com.example.projectbmi.ui.components.UserChatBubble
import com.example.projectbmi.ui.components.AIChatBubble
import com.example.projectbmi.ui.components.AITypingIndicator
import com.example.projectbmi.utils.NetworkUtils
import kotlinx.coroutines.launch
import android.widget.Toast
import com.example.projectbmi.questionnaire.*
import com.example.projectbmi.ui.screens.ModernAISuggestionsSection
import com.example.projectbmi.ui.screens.ModernChatSection
import com.example.projectbmi.ui.screens.ModernSummaryScreen
import com.example.projectbmi.ui.screens.SummaryState

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AskAIScreenClean(
    navController: NavController,
    userBMICategory: String = "normal",
    onSaveSchedule: (schedule: List<QuestTask>) -> Unit
) {
    val context = LocalContext.current
    var state by remember { mutableStateOf(UserDiscoveryState(bmiCategory = userBMICategory)) }
    var generated by remember { mutableStateOf<List<QuestTask>?>(null) }
    var regenerationVersion by remember { mutableStateOf(0) }  // Track regenerations
    var isRegenerating by remember { mutableStateOf(false) }  // Track loading state
    var regenerateCount by remember { mutableStateOf(0) }  // Track how many times regenerated
    val maxRegenerations = 4  // Limit to 4 regenerations (5 pools total - 1 initial generation)
    val generatedSchedulesHistory = remember { mutableStateListOf<List<QuestTask>>() }  // Track ALL generated schedules
    val usedPoolIndices = remember { mutableStateListOf<Int>() }  // Track ALL used pool indices
    var selectedAnswer by remember { mutableStateOf<String?>(null) }  // Track selected answer for visual feedback
    var isAdvancing by remember { mutableStateOf(false) }  // Track if advancing to next question
    var hasGeneratedOnce by remember { mutableStateOf(false) }  // Track if we've already generated once in this session

    // AI chat state
    var aiTips by remember { mutableStateOf<List<String>>(emptyList()) }
    var aiRequestedForChat by remember { mutableStateOf(false) }
    var aiSummary by remember { mutableStateOf<String?>(null) }
    var isGeneratingSummary by remember { mutableStateOf(false) }

    val scope = rememberCoroutineScope()
    
    // Gradient background colors
    val gradientColors = listOf(
        Color(0xFFF8F9FF),
        Color(0xFFE8ECFF)
    )

    Box(modifier = Modifier
        .fillMaxSize()
        .background(Brush.verticalGradient(gradientColors))
    ) {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text("Ask AI / Discovery") },
                    navigationIcon = {
                        IconButton(onClick = { 
                            // Handle back navigation based on current step
                            when {
                                generated != null -> {
                                    // If viewing generated schedule, go back to summary (but DON'T clear generated)
                                    state = state.copy(currentStep = 7)
                                }
                                state.currentStep > 1 -> {
                                    // If in questions/chat/summary, go to previous step
                                    state = state.copy(currentStep = state.currentStep - 1)
                                }
                                else -> {
                                    // If at first step, exit to previous screen
                                    navController.popBackStack()
                                }
                            }
                        }) { Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back") }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color.Transparent
                    )
                )
            },
            containerColor = Color.Transparent
        ) { paddingValues ->
        val scrollState = rememberScrollState()

        // Log when generated state changes
        LaunchedEffect(generated, regenerationVersion) {
            android.util.Log.d("AskAI", "Generated state changed: ${generated?.size ?: "null"}, version: $regenerationVersion")
        }
        
        // Ensure background async work runs in a composable-safe coroutine
        LaunchedEffect(state.currentStep, aiRequestedForChat) {
            if (state.currentStep == 6 && !aiRequestedForChat) {
                aiRequestedForChat = true
                scope.launch {
                    try {
                        // Save user profile to SharedPreferences for notifications
                        val prefs = context.getSharedPreferences("user_profile", android.content.Context.MODE_PRIVATE)
                        val userJson = com.google.gson.Gson().toJson(state)
                        prefs.edit().putString("user_state", userJson).apply()
                        
                        val params = DailyQuestParams(
                            bmiCategory = state.bmiCategory,
                            goal = state.primaryGoal ?: "maintain",
                            intensity = state.exerciseIntensity ?: "medium",
                            timeAvailable = mapDaysToTime(state.daysAvailable),
                            daysPerWeek = mapDaysToDaysPerWeek(state.daysAvailable),
                            focusArea = state.focusArea ?: "mixed",
                            healthStatus = "healthy",
                            exerciseHistory = state.experienceLevel ?: "intermediate",
                            dietaryPreference = "omnivore"
                        )
                        // Generate personalized tips based on user's answers
                        val tipsPrompt = buildString {
                            append("Based on the user's fitness profile:\n")
                            append("- Goal: ${state.primaryGoal ?: "maintain fitness"}\n")
                            append("- Intensity preference: ${state.exerciseIntensity ?: "medium"}\n")
                            append("- Available days: ${state.daysAvailable ?: "3-4 days"}\n")
                            append("- Experience level: ${state.experienceLevel ?: "intermediate"}\n")
                            append("- Focus areas: ${state.focusArea ?: "mixed/balanced"}\n")
                            append("- BMI category: ${state.bmiCategory}\n")
                            append("\nProvide 3-4 personalized workout tips that match their profile (keep each tip short, 1-2 sentences)")
                        }
                        
                        // Generate default tips based on profile
                        aiTips = generateDefaultTips(state)
                    } catch (_: Exception) {
                        aiTips = emptyList()
                    }
                }
            }
        }

        // When showing preview or questionnaire (steps 1-5), don't use verticalScroll
        // Avoid nested scroll: summary screen (step 7) already scrolls internally
        val isQuestionnaire = state.currentStep in 1..5
        val isSummary = state.currentStep == 7
        val useScroll = generated == null && !isQuestionnaire && !isSummary
        
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .then(if (!isQuestionnaire) Modifier.padding(16.dp) else Modifier)
                .then(if (useScroll) Modifier.verticalScroll(scrollState) else Modifier),
            verticalArrangement = if (isQuestionnaire) Arrangement.Top else Arrangement.spacedBy(16.dp)
        ) {
            // Progress indicator (only show for non-questionnaire steps)
            if (!isQuestionnaire) {
                LinearProgressIndicator(progress = { (state.currentStep - 1) / 7f }, modifier = Modifier.fillMaxWidth())
            }

            when {
                generated != null -> {
                    key(regenerationVersion) {
                        PreviewAndSave(
                            schedule = generated!!,
                            isLoading = isRegenerating,
                            regenerateCount = regenerateCount,
                            maxRegenerations = maxRegenerations,
                            onSave = {
                                onSaveSchedule(generated!!)
                                
                                // Schedule alarm for daily 6 AM reminder
                                try {
                                    AlarmHelper.scheduleWorkoutReminder(context)
                                    android.util.Log.d("AskAI", "Alarm scheduled for daily reminders")
                                } catch (e: Exception) {
                                    android.util.Log.e("AskAI", "Error scheduling alarm: ${e.message}", e)
                                }
                            
                                // Clear schedule history after save
                            generatedSchedulesHistory.clear()
                            usedPoolIndices.clear()
                            regenerateCount = 0
                            hasGeneratedOnce = false  // Reset flag so next generation works
                            android.util.Log.d("AskAI", "Schedule saved, history cleared, hasGeneratedOnce reset")
                            
                            // Navigate to result page with BMI data
                            val prefs = context.getSharedPreferences("bmi_prefs", android.content.Context.MODE_PRIVATE)
                            val bmi = prefs?.getString("last_bmi", "0.0") ?: "0.0"
                            val category = prefs?.getString("last_category", "Normal Weight") ?: "Normal Weight"
                            val gender = prefs?.getString("last_gender", "Male") ?: "Male"
                            
                            android.util.Log.d("AskAI", "Navigation params - BMI: $bmi, Category: $category, Gender: $gender")
                            
                            val encodedCategory = java.net.URLEncoder.encode(category, "UTF-8")
                            navController.navigate("result/$bmi/$encodedCategory/$gender")
                        },
                        onRegenerate = {
                            // Check if regeneration limit reached
                            if (regenerateCount >= maxRegenerations) {
                                android.util.Log.d("AskAI", "Regenerate limit reached: $regenerateCount/$maxRegenerations")
                                android.widget.Toast.makeText(
                                    context,
                                    "Maximum regenerations reached (${maxRegenerations}x). Please save this schedule or go back.",
                                    android.widget.Toast.LENGTH_SHORT
                                ).show()
                                return@PreviewAndSave
                            }
                            
                            // Regenerate schedule with same params - ensure uniqueness
                            isRegenerating = true
                            regenerateCount++
                            android.util.Log.d("AskAI", "Regenerate clicked #$regenerateCount/$maxRegenerations")
                            android.util.Log.d("AskAI", "Current history size: ${generatedSchedulesHistory.size}, Used pools: $usedPoolIndices")
                            scope.launch {
                                try {
                                    // Long delay (5 seconds) to ensure random seed is VERY different
                                    kotlinx.coroutines.delay(5000)
                                    android.util.Log.d("AskAI", "5 second delay complete, calling generate...")
                                    
                                    val params = DailyQuestParams(
                                        bmiCategory = state.bmiCategory,
                                        goal = state.primaryGoal ?: "maintain",
                                        intensity = state.exerciseIntensity ?: "medium",
                                        timeAvailable = mapDaysToTime(state.daysAvailable),
                                        daysPerWeek = mapDaysToDaysPerWeek(state.daysAvailable),
                                        focusArea = state.focusArea ?: "mixed",
                                        healthStatus = "healthy",
                                        exerciseHistory = state.experienceLevel ?: "intermediate",
                                        dietaryPreference = "omnivore"
                                    )
                                    
                                    // Try to generate unique schedule (max 5 attempts)
                                    var newSchedule: List<QuestTask>? = null
                                    var attempts = 0
                                    val maxAttempts = 5
                                    
                                    while (attempts < maxAttempts) {
                                        attempts++
                                        android.util.Log.d("AskAI", "Generation attempt $attempts/$maxAttempts, excluding pools: $usedPoolIndices")
                                        
                                        val candidate = AIRepository.generateWeeklySchedule(params, excludePoolIndices = usedPoolIndices.toList())
                                        val candidatePoolIndex = AIRepository.lastGeneratedPoolIndex
                                        
                                        // Check if this schedule is unique (compare with history)
                                        val isUnique = generatedSchedulesHistory.none { existingSchedule ->
                                            schedulesSimilar(existingSchedule, candidate)
                                        }
                                        
                                        android.util.Log.d("AskAI", "Attempt $attempts: Pool $candidatePoolIndex, Unique: $isUnique")
                                        
                                        if (isUnique) {
                                            newSchedule = candidate
                                            generatedSchedulesHistory.add(candidate)
                                            usedPoolIndices.add(candidatePoolIndex)
                                            android.util.Log.d("AskAI", "SUCCESS! Found unique schedule on attempt $attempts. Pool: $candidatePoolIndex")
                                            android.util.Log.d("AskAI", "First task: ${candidate.firstOrNull()?.task ?: "none"}")
                                            break
                                        } else {
                                            android.util.Log.d("AskAI", "Schedule similar to existing, retrying...")
                                        }
                                    }
                                    
                                    if (newSchedule != null) {
                                        generated = newSchedule
                                        android.util.Log.d("AskAI", "Generated NEW unique schedule, size: ${newSchedule.size}")
                                    } else {
                                        android.util.Log.w("AskAI", "Could not generate unique schedule after $maxAttempts attempts, using last attempt")
                                        generated = AIRepository.generateWeeklySchedule(params, excludePoolIndices = usedPoolIndices.toList())
                                        generated?.let { 
                                            generatedSchedulesHistory.add(it)
                                            usedPoolIndices.add(AIRepository.lastGeneratedPoolIndex)
                                        }
                                    }
                                    
                                    regenerationVersion++  // Force recomposition
                                    android.util.Log.d("AskAI", "Regenerated schedule, version now: $regenerationVersion")
                                    android.util.Log.d("AskAI", "Total schedules in history: ${generatedSchedulesHistory.size}")
                                } catch (e: Exception) {
                                    android.util.Log.e("AskAI", "Error regenerating", e)
                                    generated = emptyList()
                                } finally {
                                    isRegenerating = false
                                    android.util.Log.d("AskAI", "Regenerate complete, isRegenerating = false")
                                }
                            }
                        }
                    )
                    }
                }

                state.currentStep in 1..5 -> {
                    // ═══════════════════════════════════════════════════
                    // CLEAN ARCHITECTURE: Single reusable component for ALL screens
                    // Zero code duplication - all 5 screens use same QuestionnaireScreen
                    // ═══════════════════════════════════════════════════
                    
                    val screenIndex = state.currentStep - 1
                    var currentScreen = QuestionnaireData.screens[screenIndex]
                    
                    // For step 1 (fitness goal), filter options based on BMI category
                    if (state.currentStep == 1) {
                        android.util.Log.d("AskAI", "Filtering goals for BMI category: '${state.bmiCategory}'")
                        val filteredGoalOptions = QuestionnaireData.getFilteredGoalOptions(state.bmiCategory)
                        android.util.Log.d("AskAI", "Original options: ${currentScreen.options.size}, Filtered: ${filteredGoalOptions.size}")
                        currentScreen = currentScreen.copy(options = filteredGoalOptions)
                    }
                    
                    // Build selected options set based on current screen
                    val selectedOptions = when (state.currentStep) {
                        1 -> state.primaryGoal?.let { setOf(it) } ?: emptySet()
                        2 -> state.exerciseIntensity?.let { setOf(it) } ?: emptySet()
                        3 -> state.daysAvailable?.let { setOf(it) } ?: emptySet()
                        4 -> state.experienceLevel?.let { setOf(it) } ?: emptySet()
                        5 -> state.focusArea?.split(",")?.toSet() ?: emptySet()  // Multi-select: comma-separated string
                        else -> emptySet()
                    }
                    
                    // Use enhanced questionnaire screen
                    EnhancedQuestionnaireScreen(
                        screen = currentScreen,
                        stepNumber = state.currentStep,
                        totalSteps = 5,
                        selectedOptions = selectedOptions,
                        onSelectionChange = { value ->
                            // Update state based on questionnaire step
                            state = when (state.currentStep) {
                                1 -> state.copy(primaryGoal = value)  // Fitness goal
                                2 -> state.copy(exerciseIntensity = value)  // Intensity level
                                3 -> state.copy(daysAvailable = value)  // Days per week
                                4 -> state.copy(experienceLevel = value)  // Experience level
                                5 -> {
                                    // Multi-select: toggle add/remove (comma-separated)
                                    val currentSet = state.focusArea?.split(",")?.toMutableSet() ?: mutableSetOf()
                                    if (value in currentSet) {
                                        currentSet.remove(value)
                                    } else {
                                        currentSet.add(value)
                                    }
                                    val newFocusArea = if (currentSet.isEmpty()) null else currentSet.joinToString(",")
                                    state.copy(focusArea = newFocusArea)
                                }
                                else -> state
                            }
                            
                            // Auto-advance after 800ms for single-select (steps 1-4)
                            if (state.currentStep < 5) {
                                scope.launch {
                                    kotlinx.coroutines.delay(800)
                                    state = state.copy(currentStep = state.currentStep + 1)
                                }
                            }
                        },
                        onNextClick = {
                            // Manual advance for multi-select (step 5) or end of questionnaire
                            if (state.currentStep < 5) {
                                state = state.copy(currentStep = state.currentStep + 1)
                            } else {
                                // Last step - show AI tips/chat
                                state = state.copy(currentStep = 6)
                            }
                        },
                        progress = state.currentStep / 5f
                    )
                }

                state.currentStep == 6 -> {
                    Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
                        // Modern AI Suggestions Section
                        ModernAISuggestionsSection(tips = aiTips)

                        // Modern Chat Section
                        ModernChatSection(
                            onSendMessage = { messageCopy ->
                                try {
                                    if (!NetworkUtils.isInternetAvailable(context)) {
                                        return@ModernChatSection "❌ No internet connection. Please check your network."
                                    }

                                    // Read current BMI data from SharedPreferences
                                    val prefs = context.getSharedPreferences("bmi_prefs", android.content.Context.MODE_PRIVATE)
                                    val currentBmi = prefs?.getString("last_bmi", "Not recorded") ?: "Not recorded"
                                    val currentCategory = prefs?.getString("last_category", "Unknown") ?: "Unknown"

                                    // Build comprehensive user profile context with all discovery answers AND BMI data
                                    val contextProfile = """
User Fitness Profile (From Enhanced Questionnaire):
- Primary Goal: ${state.primaryGoal ?: "Not specified"}
- Exercise Intensity: ${state.exerciseIntensity ?: "Not specified"}
- Days Available Per Week: ${state.daysAvailable ?: "Not specified"}
- Experience Level: ${state.experienceLevel ?: "Not specified"}
- Focus Areas: ${state.focusArea ?: "Not specified"}
- BMI Category: ${state.bmiCategory}

Current Health Metrics:
- Current BMI: $currentBmi
- BMI Category: $currentCategory

Context: You are a personalized fitness and health coach. Use the above profile and health metrics to give specific, actionable advice tailored to their goals, intensity preference, available days, experience level, and focus areas. When user asks about their progress, compare their current metrics to their fitness goals.
                                    """.trimIndent()
                                    return@ModernChatSection DeepseekRepository.sendMessage(messageCopy, contextProfile)
                                } catch (e: Exception) {
                                    return@ModernChatSection "⚠️ Error: ${e.localizedMessage ?: "AI failed to respond"}"
                                }
                            },
                            onGenerateSummary = {
                                // Generate summary in background coroutine
                                isGeneratingSummary = true
                                scope.launch {
                                    try {
                                        // Check internet connection first
                                        if (!NetworkUtils.isInternetAvailable(context)) {
                                            aiSummary = "⚠️ No internet connection. Please check your network."
                                            android.util.Log.e("AskAI", "No internet for summary generation")
                                            return@launch
                                        }

                                        val summaryPrompt = """
Based on the user's profile, create a personalized fitness and wellness summary:

User Discovery Profile:
- Primary Goal: ${state.primaryGoal ?: "Not specified"}
- Exercise Intensity: ${state.exerciseIntensity ?: "Not specified"}
- Days Available: ${state.daysAvailable ?: "Not specified"}
- Experience Level: ${state.experienceLevel ?: "Not specified"}
- Focus Area: ${state.focusArea ?: "Not specified"}
- BMI Category: ${state.bmiCategory}

Please provide:
1. A personalized wellness summary
2. 3-5 key action items tailored to their specific situation
3. A motivational message
4. Next steps to build on their momentum

Keep the summary concise but comprehensive.
                                        """.trimIndent()

                                        android.util.Log.d("AskAI", "Starting summary generation...")
                                        val result = DeepseekRepository.sendMessage(summaryPrompt, "")
                                        android.util.Log.d("AskAI", "Summary generated successfully: ${result.take(50)}...")
                                        aiSummary = result
                                        // Auto-advance to next step after generating summary
                                        state = state.copy(currentStep = 7)
                                    } catch (e: Exception) {
                                        android.util.Log.e("AskAI", "Summary generation error: ${e.message}", e)
                                        aiSummary = "⚠️ Could not generate summary: ${e.message ?: "Unknown error"}"
                                    } finally {
                                        isGeneratingSummary = false
                                    }
                                }
                            }
                        )
                    }
                }

                state.currentStep == 7 -> {
                    ModernSummaryScreen(
                        summaryState = SummaryState(
                            aiSummary = aiSummary.orEmpty(),
                            goal = state.primaryGoal.orEmpty(),
                            intensity = state.exerciseIntensity.orEmpty(),
                            daysAvailable = state.daysAvailable.orEmpty(),
                            experienceLevel = state.experienceLevel.orEmpty(),
                            focusArea = state.focusArea.orEmpty(),
                            isLoading = isGeneratingSummary || state.isLoading
                        ),
                        onGenerateClick = {
                            // Only generate if we haven't generated yet in this session
                            if (hasGeneratedOnce) {
                                android.util.Log.d("AskAI", "Schedule already generated in this session, skipping regeneration")
                                Toast.makeText(context, "Schedule already generated. Click Regenerate to create a new one or Save to finish.", Toast.LENGTH_SHORT).show()
                            } else {
                                android.util.Log.d("AskAI", "Generate button clicked at step 7")
                                state = state.copy(isLoading = true)
                                scope.launch {
                                    try {
                                        val params = DailyQuestParams(
                                            bmiCategory = state.bmiCategory,
                                    goal = state.primaryGoal ?: "maintain",
                                    intensity = state.exerciseIntensity ?: "medium",
                                    timeAvailable = mapDaysToTime(state.daysAvailable),
                                    daysPerWeek = mapDaysToDaysPerWeek(state.daysAvailable),
                                    focusArea = state.focusArea ?: "mixed",
                                    healthStatus = "healthy",
                                    exerciseHistory = state.experienceLevel ?: "intermediate",
                                    dietaryPreference = "omnivore"
                                )
                                android.util.Log.d("AskAI", "Generating INITIAL schedule with params: $params")
                                generated = AIRepository.generateWeeklySchedule(params, excludePoolIndices = emptyList())  // First generation, no exclusion
                                val poolIndex = AIRepository.lastGeneratedPoolIndex
                                
                                // Store in history
                                generated?.let { schedule ->
                                    generatedSchedulesHistory.clear()  // Clear old history for fresh start
                                    usedPoolIndices.clear()
                                    generatedSchedulesHistory.add(schedule)
                                    usedPoolIndices.add(poolIndex)
                                    hasGeneratedOnce = true  // Mark that we've generated
                                    regenerateCount = 0  // Reset regenerate count for this generation
                                    android.util.Log.d("AskAI", "Stored initial schedule in history. Pool: $poolIndex, hasGeneratedOnce: true")
                                }
                                
                                // Removed artificial delay to make generation feel instant
                                regenerationVersion++  // Force recomposition on first generate
                                android.util.Log.d("AskAI", "Generated INITIAL schedule size: ${generated?.size ?: 0}, version: $regenerationVersion, pool index: $poolIndex")
                                generated?.forEachIndexed { idx, task ->
                                    android.util.Log.d("AskAI", "Task $idx: ${task.day} - ${task.task}")
                                }
                            } catch (e: Exception) {
                                android.util.Log.e("AskAI", "Error generating schedule", e)
                                generated = emptyList()
                            }
                            state = state.copy(isLoading = false)
                            }
                        }
                    },
                        onBackClick = { state = state.copy(currentStep = 6) }
                    )
                }
            }
        }
    }
    }  // Close Box
}
// ═══════════════════════════════════════════════════
// OLD COMPONENTS (Kept for backward compatibility)
// These are no longer used - all screens now use QuestionnaireScreen
// ═══════════════════════════════════════════════════

// Reusable question composables to ensure consistent spacing and protect against large font scales
@Composable
fun QuestionStepRadio(
    title: String,
    options: List<Pair<String, String>>,
    selectedValue: String?,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onSelect: (String) -> Unit
) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(
            title,
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold,
            modifier = Modifier
                .fillMaxWidth()
                .heightIn(min = 52.dp)
                .padding(bottom = 8.dp),
            maxLines = 3,
            overflow = TextOverflow.Ellipsis
        )

        Spacer(modifier = Modifier.height(10.dp))

        Column(verticalArrangement = Arrangement.spacedBy(10.dp)) {
            options.forEach { (label, value) ->
                val isSelected = selectedValue == value
                val isJustSelected = selectedAnswer == value && isAdvancing
                
                // Animasi scale untuk item yang dipilih
                val scale by animateFloatAsState(
                    targetValue = if (isJustSelected) 1.05f else 1f,
                    animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy, stiffness = Spring.StiffnessLow),
                    label = "scale"
                )
                
                val backgroundColor = when {
                    isJustSelected -> MaterialTheme.colorScheme.primaryContainer
                    isSelected -> MaterialTheme.colorScheme.surfaceVariant
                    else -> MaterialTheme.colorScheme.surface
                }
                
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .graphicsLayer(scaleX = scale, scaleY = scale),
                    colors = CardDefaults.cardColors(containerColor = backgroundColor)
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .selectable(
                                selected = isSelected,
                                onClick = { if (!isAdvancing) onSelect(value) }
                            )
                            .heightIn(min = 56.dp)
                            .padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        RadioButton(
                            selected = isSelected,
                            onClick = { if (!isAdvancing) onSelect(value) }
                        )
                        Spacer(modifier = Modifier.width(14.dp))
                        Text(
                            label,
                            fontSize = 16.sp,
                            modifier = Modifier.weight(1f),
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis,
                            fontWeight = if (isJustSelected) FontWeight.Bold else FontWeight.Normal
                        )
                        // Show checkmark when selected
                        if (isJustSelected) {
                            Spacer(modifier = Modifier.width(8.dp))
                            Text("✓", fontSize = 20.sp, color = MaterialTheme.colorScheme.primary)
                        }
                    }
                }
            }
        }
        
        // Show "Moving to next question..." when advancing
        AnimatedVisibility(visible = isAdvancing) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 16.dp),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                CircularProgressIndicator(modifier = Modifier.size(16.dp), strokeWidth = 2.dp)
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    "Moving to next question...",
                    fontSize = 14.sp,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
fun QuestionStepCheckbox(
    title: String,
    options: List<String>,
    selected: List<String>,
    onToggle: (String) -> Unit
) {
    Column(modifier = Modifier.fillMaxWidth()) {
        Text(
            title,
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold,
            modifier = Modifier
                .fillMaxWidth()
                .heightIn(min = 52.dp)
                .padding(bottom = 8.dp),
            maxLines = 3,
            overflow = TextOverflow.Ellipsis
        )

        Spacer(modifier = Modifier.height(10.dp))

        Column(verticalArrangement = Arrangement.spacedBy(10.dp)) {
            options.forEach { label ->
                val isSelected = selected.contains(label)
                
                // Animasi scale untuk item yang dipilih
                val scale by animateFloatAsState(
                    targetValue = if (isSelected) 1.02f else 1f,
                    animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy),
                    label = "checkboxScale"
                )
                
                val backgroundColor = if (isSelected) {
                    MaterialTheme.colorScheme.primaryContainer
                } else {
                    MaterialTheme.colorScheme.surface
                }
                
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .graphicsLayer(scaleX = scale, scaleY = scale),
                    colors = CardDefaults.cardColors(containerColor = backgroundColor)
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable { onToggle(label) }
                            .heightIn(min = 56.dp)
                            .padding(horizontal = 12.dp, vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Checkbox(
                            checked = isSelected,
                            onCheckedChange = { onToggle(label) }
                        )
                        Spacer(modifier = Modifier.width(14.dp))
                        Text(
                            label,
                            fontSize = 16.sp,
                            modifier = Modifier.weight(1f),
                            maxLines = 2,
                            overflow = TextOverflow.Ellipsis,
                            fontWeight = if (isSelected) FontWeight.SemiBold else FontWeight.Normal
                        )
                        // Show checkmark count
                        if (isSelected) {
                            Text("✓", fontSize = 20.sp, color = MaterialTheme.colorScheme.primary)
                        }
                    }
                }
            }
        }
        
        // Show selection count
        if (selected.isNotEmpty()) {
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                "${selected.size} selected",
                fontSize = 14.sp,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Medium
            )
        }
    }
}

@Composable
fun StepPrimaryGoal(
    state: UserDiscoveryState,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onStateChange: (UserDiscoveryState) -> Unit
) {
    val options = listOf("Lose weight" to "weight-loss", "Gain weight" to "gain", "Maintain ideal weight" to "maintain", "Check BMI status" to "check")
    QuestionStepRadio(
        title = "What is your primary goal for using this app?",
        options = options,
        selectedValue = state.primaryGoal,
        selectedAnswer = selectedAnswer,
        isAdvancing = isAdvancing
    ) { value ->
        onStateChange(state.copy(primaryGoal = value))
    }
}

@Composable
fun StepExerciseFrequency(
    state: UserDiscoveryState,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onStateChange: (UserDiscoveryState) -> Unit
) {
    val options = listOf("Never" to "never", "1 - 2 times" to "one-two", "3 - 5 times" to "three-five", "Daily" to "daily")
    QuestionStepRadio(
        title = "How often do you exercise per week?",
        options = options,
        selectedValue = state.exerciseFrequency,
        selectedAnswer = selectedAnswer,
        isAdvancing = isAdvancing
    ) { value ->
        onStateChange(state.copy(exerciseFrequency = value))
    }
}

@Composable
fun StepEatingPattern(
    state: UserDiscoveryState,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onStateChange: (UserDiscoveryState) -> Unit
) {
    val options = listOf("Irregular" to "irregular", "Overeating" to "overeating", "Balanced" to "balanced", "Specific diet" to "specific")
    QuestionStepRadio(
        title = "What is your typical eating pattern?",
        options = options,
        selectedValue = state.eatingPattern,
        selectedAnswer = selectedAnswer,
        isAdvancing = isAdvancing
    ) { value ->
        onStateChange(state.copy(eatingPattern = value))
    }
}

@Composable
fun StepSleepHours(
    state: UserDiscoveryState,
    selectedAnswer: String? = null,
    isAdvancing: Boolean = false,
    onStateChange: (UserDiscoveryState) -> Unit
) {
    val options = listOf("< 5 hours" to "less-5", "5-7" to "5-7", "7-9" to "7-9", "> 9" to "more-9")
    QuestionStepRadio(
        title = "How many hours do you usually sleep per night?",
        options = options,
        selectedValue = state.sleepHours,
        selectedAnswer = selectedAnswer,
        isAdvancing = isAdvancing
    ) { value ->
        onStateChange(state.copy(sleepHours = value))
    }
}

@Composable
fun StepChallenges(state: UserDiscoveryState, onStateChange: (UserDiscoveryState) -> Unit) {
    val options = listOf("Finding time", "Diet pattern", "Lack of motivation", "Busy schedule", "Other")
    QuestionStepCheckbox(title = "What do you find most challenging about maintaining your ideal weight?", options = options, selected = state.challenges) { toggled ->
        val new = if (state.challenges.contains(toggled)) state.challenges - toggled else state.challenges + toggled
        onStateChange(state.copy(challenges = new))
    }
}

@Composable
fun PreviewAndSave(
    schedule: List<QuestTask>, 
    isLoading: Boolean = false, 
    regenerateCount: Int = 0,
    maxRegenerations: Int = 2,
    onSave: () -> Unit, 
    onRegenerate: () -> Unit
) {
    android.util.Log.d("PreviewAndSave", "Rendering: Schedule size: ${schedule.size}, isLoading: $isLoading, regenerateCount: $regenerateCount")
    if (schedule.isNotEmpty()) {
        android.util.Log.d("PreviewAndSave", "Schedule items: ${schedule.map { "${it.day}: ${it.task}" }}")
    }
    
    Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.spacedBy(12.dp)) {
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween, verticalAlignment = Alignment.CenterVertically) {
            Text("Preview Schedule", style = MaterialTheme.typography.headlineSmall, fontWeight = FontWeight.Bold)
            if (regenerateCount > 0) {
                Text(
                    "Regenerated: $regenerateCount/$maxRegenerations",
                    style = MaterialTheme.typography.bodySmall,
                    color = if (regenerateCount >= maxRegenerations) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
        
        if (isLoading) {
            Box(modifier = Modifier.weight(1f).fillMaxWidth(), contentAlignment = Alignment.Center) {
                Column(horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(12.dp)) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(48.dp),
                        color = MaterialTheme.colorScheme.primary,
                        strokeWidth = 4.dp
                    )
                    Text("Generating new schedule...", style = MaterialTheme.typography.bodyMedium, color = MaterialTheme.colorScheme.onSurfaceVariant)
                }
            }
        } else if (schedule.isEmpty()) {
            Box(modifier = Modifier.weight(1f).fillMaxWidth(), contentAlignment = Alignment.Center) {
                Text("No schedule generated yet", color = MaterialTheme.colorScheme.onSurfaceVariant)
            }
        } else {
            LazyColumn(
                modifier = Modifier.weight(1f).fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(schedule) { task ->
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            horizontalArrangement = Arrangement.SpaceBetween,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Column(modifier = Modifier.weight(1f)) {
                                Text(
                                    task.day.uppercase(),
                                    fontWeight = FontWeight.Bold,
                                    style = MaterialTheme.typography.labelLarge,
                                    color = MaterialTheme.colorScheme.primary
                                )
                                Spacer(modifier = Modifier.height(4.dp))
                                Text(
                                    task.task,
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    }
                }
            }
        }
        
        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
            OutlinedButton(
                onClick = onRegenerate, 
                modifier = Modifier.weight(1f), 
                enabled = !isLoading && regenerateCount < maxRegenerations
            ) {
                if (isLoading) {
                    CircularProgressIndicator(modifier = Modifier.size(20.dp), strokeWidth = 2.dp, color = MaterialTheme.colorScheme.onSurface)
                } else {
                    Text(if (regenerateCount >= maxRegenerations) "Limit Reached" else "Regenerate")
                }
            }
            Button(onClick = onSave, modifier = Modifier.weight(1f), enabled = !isLoading) {
                Text("Save")
            }
        }
    }
}

fun mapFrequencyToIntensity(freq: String?): String = when (freq) {
    "never" -> "low"
    "one-two" -> "low"
    "three-five" -> "medium"
    "daily" -> "high"
    else -> "medium"
}

fun mapExerciseFrequencyToHistory(freq: String?): String = when (freq) {
    "never" -> "beginner"
    "one-two" -> "inconsistent"
    "three-five" -> "active"
    "daily" -> "active"
    else -> "beginner"
}

fun mapDaysToTime(days: String?): Int = when (days) {
    "3-4" -> 30
    "5-6" -> 45
    "7" -> 60
    else -> 45
}

fun mapDaysToDaysPerWeek(days: String?): Int = when (days) {
    "3-4" -> 4
    "5-6" -> 6
    "7" -> 7
    else -> 7
}

fun schedulesSimilar(schedule1: List<QuestTask>, schedule2: List<QuestTask>): Boolean {
    if (schedule1.size != schedule2.size) return false
    
    var matchingTasks = 0
    for (i in schedule1.indices) {
        if (schedule1[i].task == schedule2[i].task) {
            matchingTasks++
        }
    }
    
    val similarityThreshold = 0.5
    val similarity = matchingTasks.toDouble() / schedule1.size.toDouble()
    
    android.util.Log.d("ScheduleComparison", "Matching tasks: $matchingTasks/${schedule1.size}, Similarity: ${similarity * 100}%")
    
    return similarity > similarityThreshold
}

fun generateDefaultTips(state: UserDiscoveryState): List<String> {
    val tips = mutableListOf<String>()
    
    val goal = state.primaryGoal?.lowercase() ?: "maintain"
    val intensity = state.exerciseIntensity?.lowercase() ?: "medium"
    val experience = state.experienceLevel?.lowercase() ?: "intermediate"
    val focusArea = state.focusArea?.lowercase() ?: "mixed"
    
    // Tip based on goal
    when {
        goal.contains("weight loss") -> tips.add("For weight loss, combine cardio 3-4x/week with strength training to preserve muscle while burning calories.")
        goal.contains("muscle") -> tips.add("To build muscle, prioritize compound exercises (squats, deadlifts) with progressive overload and adequate protein intake.")
        goal.contains("cardio") -> tips.add("For pure cardio focus: mix running, cycling, or swimming. Vary your pace to prevent plateaus.")
        else -> tips.add("Maintain moderate intensity with proper rest periods. This allows for sustainable long-term progress.")
    }
    
    // Tip based on intensity
    when {
        intensity.contains("high") -> tips.add("With high intensity training, ensure 48 hours recovery between intense sessions to prevent overtraining.")
        intensity.contains("low") -> tips.add("Start with light to moderate intensity, focusing on form and consistency before increasing difficulty.")
        else -> tips.add("Maintain moderate intensity with proper rest periods. This allows for sustainable long-term progress.")
    }
    
    // Tip based on experience
    when {
        experience.contains("beginner") -> tips.add("Focus on mastering proper form before increasing weight or intensity. Consistency beats perfection.")
        experience.contains("intermediate") -> tips.add("You're ready to incorporate progressive overload. Track your metrics and aim to improve weekly.")
        else -> tips.add("Challenge yourself with new variations and advanced techniques to continue improving.")
    }
    
    // Tip based on focus area
    if (focusArea.contains("cardio") && focusArea.contains("strength")) {
        tips.add("Balance cardio and strength training: 2-3 strength sessions and 2-3 cardio sessions per week for optimal results.")
    } else if (focusArea.contains("cardio")) {
        tips.add("Mix steady-state and interval cardio to improve endurance while keeping workouts engaging.")
    } else if (focusArea.contains("strength")) {
        tips.add("Prioritize compound lifts and track progressive overload weekly to build strength consistently.")
    } else {
        tips.add("Keep a balanced split: alternate cardio and strength days to recover better and avoid plateaus.")
    }

    // Ensure we always return 4 tips by adding curated fallbacks
    val fallbacks = listOf(
        "Stay hydrated and aim for 7-9 hours of sleep to support recovery and performance.",
        "Schedule workouts on your calendar to build consistency and reduce decision fatigue.",
        "Warm up for 5-10 minutes and cool down to reduce injury risk and improve mobility.",
        "Track small wins weekly to stay motivated and see progress over time."
    )

    val uniqueTips = tips.distinct().toMutableList()
    var i = 0
    while (uniqueTips.size < 4 && i < fallbacks.size) {
        if (!uniqueTips.contains(fallbacks[i])) uniqueTips.add(fallbacks[i])
        i++
    }

    return uniqueTips.take(4)
}

// lightweight local state type shared with this file
// UserDiscoveryState is now defined in `UserDiscoveryState.kt` to be shared across files.
